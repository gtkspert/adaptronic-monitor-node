var StreamStack = require('stream-stack').StreamStack;
var Put = require('put');
var BufferList = require('bufferlist').BufferList;
var Binary = require('bufferlist/binary').Binary;
var NBinary = require('binary');
var Buffers = require('buffers');
var inherits = require('util').inherits;
var client = require('./client');
var server = require('./server');
var slice = Array.prototype.slice;

// The byte length of the "MODBUS Application Protocol" header.
const MBAP_LENGTH = 7;

// The byte length of the "MODBUS Function Code".
const FUNCTION_CODE_LENGTH = 1;

// An exception response from a MODBUS slave (server) will have
// the high-bit (0x80) set on it's function code.
const EXCEPTION_BIT = 1 << 7;

// If it's an exception response, then the next byte will be one
// these exception codes, indicating the reason for the failure.
exports.EXCEPTION_CODES = {
  1 : 'Illegal Function',
  2 : 'Illegal Data Address',
  3 : 'Illegal Data Value',
  4 : 'Slave Device Failure',
  5 : 'Acknowledge',
  6 : 'Slave Device Busy',
  8 : 'Memory Parity Error',
  10: 'Gateway Path Unavailable',
  11: 'Gateway Target Path Failed to Respond'
};

// Each of the function codes has a potentially different body payload
// and potentially different parameters to send. Each function code needs
// a 'request' and 'response' parser in the "client.js" and "server.js" files.
exports.FUNCTION_CODES = {
  READ_COILS:               1,
  READ_DISCRETE_INPUTS:     2,
  READ_HOLDING_REGISTERS:   3,
  READ_INPUT_REGISTERS:     4,
  WRITE_SINGLE_COIL:        5,
  WRITE_SINGLE_REGISTER:    6,
  READ_EXCEPTION_STATUS:    7, // Serial Line only
  DIAGNOSTICS:              8, // Serial Line only
  PROGRAM_484:              9,
  POLL_484:                 10,
  GET_COMM_EVENT_COUNTER:   11,// Serial Line only
  GET_COMM_EVENT_LOG:       12,// Serial Line only
  PROGRAM_CONTROLLER:       13,
  POLL_CONTROLLER:          14,
  WRITE_MULTIPLE_COILS:     15,
  WRITE_MULTIPLE_REGISTERS: 16,
  REPORT_SLAVE_ID:          17,// Serial Line only
  PROGRAM_884_M84:          18,
  RESET_COMM_LINK:          19,
  READ_FILE_RECORD:         20,
  WRITE_FILE_RECORD:        21,
  MASK_WRITE_REGISTER:      22,
  READ_WRITE_MULTIPLE_REGISTERS:23,
  READ_FIFO_QUEUE:          24,
  ENCAPSULATED_INFERFACE_TRANSPORT:43
};

function ModbusRequestStack(stream) {
  var ss = StreamStack.call(this, stream, {
    data: this._onData
  });
  this.bufferlist = new BufferList();
  if (this.stream._reqNum) {
    this.stream._reqNum++;
  } else {
    this.stream._reqNum = 1;
  }

  this.recvbuf = new Buffers();
  this.requestInProgress = false;
  this.isRawRequest = false;
  this.requestCounter = 0;
}

inherits(ModbusRequestStack, StreamStack);
exports.ModbusRequestStack = ModbusRequestStack;

// The 'version' of the MODBUS protocol. Only version 0 is defined.
ModbusRequestStack.prototype.protocolVersion = 0;

// The unit identifier to request. This is usually important for
// serial lines, not so much over TCP.
ModbusRequestStack.prototype.unitIdentifier = 1;

function scrub(self, requestCounter) {
  if (self.requestInProgress) {
    if (arguments.callee.caller.name == "timeout") {
      var err = new Error('Request ' + requestCounter + ' abandoned by timeout!');
      
      self.emit('error', err);
    } // */
    self.isRawRequest = false;
    self.recvbuf = new Buffers();
    self.responseHeader = false;
    self.requestInProgress = false;
  }
}

function calculateCRC(buf) {

  var flag;
  var crc = 0xFFFF;

  var unpacker = NBinary.parse(buf);
  unpacker
    .loop(
      function (end, val) {
        if (this.eof()) {
          end();
        } else {
          this
            .word8('w8')
            .tap(
              function(vars) {
                crc = crc ^ vars.w8;

                for (i = 0; i < 8; i++) {
                  flag = crc & 0x0001;
                  crc = crc >> 1;
                  if (flag == 1) {
                    crc = crc ^ 0xA001;
                  }
                }

              }
            )
          ;
        }
      }
    )
  ;

  // Now finish up the CRC, trim the garbage
  var temp = crc >> 8;
  crc = (crc << 8) | temp;
  crc &= 0xFFFF;

  // And split it into easy to use portions. For science.
  splitCrc = [ crc >> 8, crc & 0xFF ];
  
  return splitCrc;

}


ModbusRequestStack.prototype.bind = function(callback) {
  if (typeof(callback) == 'function') {
    this.on('error', callback);
    this.on('response', function(res) {
      callback(null, res);
    });
  }
}


ModbusRequestStack.prototype.rawRequest = function(rawRequest) {
  if (this.requestInProgress) {
    this.emit('error', new Error('Another request is already in progress...'));
    return false;
  }
  
  this.requestInProgress = true;
  
  this.isRawRequest = true;

  return this.stream.write(rawRequest);
}

// Make a MODBUS request for a given 'function code'.
ModbusRequestStack.prototype.request = function(functionCode) {
  if (!client.REQUESTS[functionCode]) {
    throw new Error('"REQUESTS['+functionCode+']" in "client.js" is not implemented!');
  }
  if (this.requestInProgress) {
    this.emit('error', new Error('Another request is already in progress...'));
    return false;
  }
  this.requestInProgress = true;
  this.requestCounter++;
  this.functionCode = functionCode;

  var self = this;
  var startTime = new Date();
//  console.log('');
//  console.log('Added timeout for request ' + this.requestCounter + ' at ' + startTime.getTime());
  this.timeout = setTimeout(function timeout() {
    scrub(self, self.requestCounter);
  }, 45);


  var args = slice.call(arguments, 1);
  try {
    var pdu = client.REQUESTS[functionCode].apply(this, args);
  } catch(e) {
    this.emit('error', e);
    return false;
  }

  var nBuf = Put()
    .word8(this.unitIdentifier)
    .word8(functionCode)
    .put(pdu)
    .buffer();
  

  var crcForBuf = calculateCRC(nBuf);

  var buf = Put()
    .put(nBuf)
    .word8(crcForBuf[0])
    .word8(crcForBuf[1])
    .buffer();

/*  var date = new Date();
  console.log("Request sent at: \t\t" + date.getTime());
*/
  this.stream.write(buf);
  return buf;

}



ModbusRequestStack.prototype._onData = function(chunk) {
  // Are we really wanting data right now?
  if (!this.requestInProgress) {
    return;
  }

  if (chunk) {
    this.recvbuf.push(chunk);
//    console.log(chunk);
  }

  //  If there's no responseHeader, check if we have enough data to process the response header
  //    responseHeader is 3 bytes
  if (!this.responseHeader && this.recvbuf.length >= 3) {
    this.responseHeader = true;

    this.responseHeader = NBinary.parse(this.recvbuf.slice(0,3))
      .word8('frameDest')
      .word8('function')
      .word8('byteCount')
      .vars;

    // Generate the total packet size (3bytes of header, 2 bytes crc);
    this.responseHeader.totalBytes = this.responseHeader.byteCount + 5;
    
    //console.log('Header has arrived, expecting ' + this.responseHeader.totalBytes + ' have ' + this.recvbuf.length);

  }

  if (this.responseHeader && (this.recvbuf.length >= this.responseHeader["totalBytes"])) {
    var endTime = new Date();
    //console.log('Clearing timeout for ' + this.requestCounter + ' at ' + endTime.getTime());
    clearTimeout(this.timeout);

    // At this point, we have a complete response
    if (this.isRawRequest) {
      this.emit('rawResponse', this.recvbuf.slice());
      scrub(this);

    } else {
      // Emit the rawResponse anyway, the above will save wasting time on injected requests anyway
      this.emit('rawResponse', this.recvbuf.slice());

      // If we have the whole packet:
      // Structure it nicerly
      var crcBytes = this.recvbuf.slice(this.recvbuf.length - 2);
      var crcData = this.recvbuf.slice(0,this.recvbuf.length - 2);
      var responseData = this.recvbuf.slice(3,this.recvbuf.length - 2);
  
  
      var calcCrc = calculateCRC(crcData);
  
      if ((calcCrc[0] != crcBytes[0]) || (calcCrc[1] != crcBytes[1])) { 
        error = "Checksum Error! Calculated: " + calcCrc + "  Received: " + crcBytes[0] + "," + crcBytes[1];
        scrub(this);
        return this.emit('error', new Error(error));
      }
  
      // Now extract the data:
      var response = client.RESPONSES[this.responseHeader.function].call(this, responseData);
      
      this.emit('response', response);
  
      // Cleanup the in-progress request
      scrub(this);

    }
  }

}

ModbusRequestStack.prototype._onNData = function(chunk) {
  if (chunk) {
    this.bufferlist.push(chunk);
    //console.log(chunk);
  }
  if (!this.responseHeader && this.bufferlist.length >= MBAP_LENGTH) {
    this.responseHeader = readMBAP(this.bufferlist);
    // Re-check the bufferlist to see if we have the rest of the response already
    this._onData();
  } else if (!this._resFunctionCode && this.responseHeader && this.bufferlist.length >= 1) {
    // Get the function code
    this._resFunctionCode = readFunctionCode(this.bufferlist);
    //console.log(this._resFunctionCode);
    this._onData();
  } else if (this.responseHeader && this._resFunctionCode >= 1 && this.bufferlist.length >= (this.responseHeader.length-2)) {
    // We have the complete response.
    if (this._resFunctionCode & EXCEPTION_BIT) {
      // An exception was returned as the response!
      var code = this.bufferlist.take(1)[0];
      this.bufferlist.advance(1);
      var err = new Error(exports.EXCEPTION_CODES[code]);
      err.errno = code;
      this.emit('error', err);
    } else {
      if (!client.RESPONSES[this._resFunctionCode]) {
        return this.emit('error', new Error('"RESPONSES['+this._resFunctionCode+']" in "client.js" is not implemented!'));
      }
      try {
        var response = client.RESPONSES[this._resFunctionCode].call(this, this.bufferlist);
      } catch(e) {
        return this.emit('error', e);
      }
      this.bufferlist.advance(this.responseHeader.length-2);
      // Explicitly set the 'functionCode' property.
      response.functionCode = this._resFunctionCode;
      delete this._resFunctionCode;
      // Modbus request/response complete; invoke callbacks and cleanup!
      this.emit('response', response);
    }
    this.cleanup();
  }
}

// Reads the "MODBUS Application Protocol" header from the given bufferlist,
// and return a object with 'transactionId', 'protocolVersion', 'length', and
// 'unitIdentifier' properties (standard for both client and server).
function readMBAP(bufferlist) {
  var mbap = Binary(bufferlist)
    .getWord16be('transactionId')
    .getWord16be('protocolVersion')
    .getWord16be('length')
    .getWord8('unitIdentifier')
    .end().vars;
  bufferlist.advance(MBAP_LENGTH);
  return mbap;
}
exports.readMBAP = readMBAP;

// Reads the "MODBUS Function Code", which comes immediately after the MBAP.
function readFunctionCode(bufferlist) {
  var rtn = bufferlist.take(FUNCTION_CODE_LENGTH)[0];
  bufferlist.advance(FUNCTION_CODE_LENGTH);
  return rtn;
}
exports.readFunctionCode = readFunctionCode;
